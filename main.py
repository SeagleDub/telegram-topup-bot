from dotenv import load_dotenv
import bugsnag
import os

load_dotenv()

API_TOKEN = os.getenv("BOT_TOKEN")
GOOGLE_SHEET_ID = os.getenv("GOOGLE_SHEET_ID")
BUGSNAG_TOKEN = os.getenv("BUGSNAG_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID"))

bugsnag.configure(
    api_key=BUGSNAG_TOKEN
)

import asyncio
from aiogram import Bot, Dispatcher, Router, F
from aiogram.filters import Command
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, ContentType, BufferedInputFile
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
import shortuuid
import gspread
import re
from PIL import Image, ImageFilter, ImageEnhance
from PIL.PngImagePlugin import PngInfo
from PIL import TiffImagePlugin
from typing import Union, Tuple, Optional, Dict, Any
import io
from io import BytesIO
import random
import string
import piexif
from datetime import datetime
import uuid
import zipfile

bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

router = Router()
dp.include_router(router)

menu_kb_user = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [KeyboardButton(text="üí∞ –ó–∞–∫–∞–∑–∞—Ç—å –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ")],
    [KeyboardButton(text="üìÇ –ó–∞–ø—Ä–æ—Å–∏—Ç—å —Ä–∞—Å—Ö–æ–¥–Ω–∏–∫–∏")],
    [KeyboardButton(text="üåê –°–æ–∑–¥–∞—Ç—å/–ø–æ—á–∏–Ω–∏—Ç—å –ª–µ–Ω–¥–∏–Ω–≥")],
    [KeyboardButton(text="üñºÔ∏è –£–Ω–∏–∫–∞–ª–∏–∑–∞—Ç–æ—Ä")]
])

menu_kb_admin = ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
    [KeyboardButton(text="üì¢ –°–¥–µ–ª–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É")]
])

cancel_kb = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True, keyboard=[
    [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
])

class Form(StatesGroup):
    waiting_for_bank = State()
    waiting_for_amount = State()
    waiting_for_type = State()
    choosing_supply_category = State()
    choosing_account_type = State()
    entering_account_quantity = State()
    entering_domain_quantity = State()
    # landing functionality
    choosing_offer_category = State()
    writing_offer_name = State()
    writing_specification = State()
    entering_canvas_link = State()
    uploading_multiple_zip_files = State()
    # unicalisation
    images_unicalization = State()
    unicalization_copies = State()
    # broadcast
    broadcast_collecting = State()

last_messages = {}

@router.message(Command("start"))
async def send_welcome(message: Message):
    if message.from_user.id == ADMIN_ID:
        await message.answer("üëë –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:", reply_markup=menu_kb_admin)
    else:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=menu_kb_user)

@router.message(F.text == "üì¢ –°–¥–µ–ª–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É")
async def admin_broadcast_start(message: Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.")
        return
    
    await state.clear()
    await state.update_data(broadcast_messages=[])
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ —Ö–æ—Ç–∏—Ç–µ —Ä–∞–∑–æ—Å–ª–∞—Ç—å.\n"
        "–ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´üöÄ –ü–æ—Å–ª–∞—Ç—å",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="üöÄ –ü–æ—Å–ª–∞—Ç—å")],
                [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
            ],
            resize_keyboard=True,
            one_time_keyboard=False
        )
    )
    await state.set_state(Form.broadcast_collecting)

@router.message(Form.broadcast_collecting, F.text == "üöÄ –ü–æ—Å–ª–∞—Ç—å")
async def send_broadcast(message: Message, state: FSMContext):
    await message.answer("–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É...")
    data = await state.get_data()
    messages = data.get("broadcast_messages", [])

    if not messages:
        await message.answer("‚ö†Ô∏è –°–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –ø—É—Å—Ç. –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=menu_kb_admin)
        await state.clear()
        return

    user_ids = get_user_ids_from_sheet()

    if not user_ids:
        await message.answer("‚ö†Ô∏è –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç. –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=menu_kb_admin)
        await state.clear()
        return

    success_count = 0
    fail_count = 0

    for user_id in user_ids:
        user_success = True
        try:
            await bot.send_message(
                user_id,
                text="*üì¢ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∞*",
                parse_mode="Markdown"
            )
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
            user_success = False
            continue  # –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        
        for msg in messages:
            try:
                await bot.copy_message(chat_id=user_id, from_chat_id=msg["chat_id"], message_id=msg["message_id"])
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
                user_success = False
                # –Ω–µ –¥–µ–ª–∞–µ–º break, —á—Ç–æ–±—ã –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è

        if user_success:
            success_count += 1
        else:
            fail_count += 1

    await message.answer(
        f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n"
        f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {success_count}\n"
        f"–ù–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {fail_count}",
        reply_markup=menu_kb_admin
    )
    await state.clear()

@router.message(Form.broadcast_collecting, F.text == "‚ùå –û—Ç–º–µ–Ω–∞")
async def cancel_broadcast(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=menu_kb_admin)

@router.message(Form.broadcast_collecting)
async def collect_broadcast_messages(message: Message, state: FSMContext):
    data = await state.get_data()
    broadcast_messages = data.get("broadcast_messages", [])

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏
    msg_data = {
        "message_id": message.message_id,
        "chat_id": message.chat.id,  # –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏
    }
    broadcast_messages.append(msg_data)
    await state.update_data(broadcast_messages=broadcast_messages)

    await message.answer("–°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Ä–∞—Å—Å—ã–ª–∫—É. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â—ë –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´üöÄ –ü–æ—Å–ª–∞—Ç—å¬ª.")

@router.message(F.text == "üåê –°–æ–∑–¥–∞—Ç—å/–ø–æ—á–∏–Ω–∏—Ç—å –ª–µ–Ω–¥–∏–Ω–≥")
async def create_landing(message: Message, state: FSMContext):
    if not is_user_allowed(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.")
        return
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üíª –°–æ–∑–¥–∞—Ç—å –ª–µ–Ω–¥–∏–Ω–≥", callback_data="landing:create")],
        [InlineKeyboardButton(text="üîß –ü–æ—á–∏–Ω–∏—Ç—å –ª–µ–Ω–¥–∏–Ω–≥", callback_data="landing:repair")]
    ])
    m1 = await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb)
    m2 = await message.answer("‚ùå –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –Ω–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏", reply_markup=cancel_kb)
    last_messages[message.from_user.id] = [m1.message_id, m2.message_id]
    await state.set_state(Form.choosing_offer_category)

@router.callback_query(F.data.startswith("landing:"), Form.choosing_offer_category)
async def landing_category_selected(query: CallbackQuery, state: FSMContext):
    await delete_last_messages(query.from_user.id, query.message)
    _, category = query.data.split(":")

    await state.update_data(landing_category=category)
    msg = await query.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ—Ñ—Ñ–µ—Ä–∞:", reply_markup=cancel_kb)
    last_messages[query.from_user.id] = [msg.message_id]
    await state.set_state(Form.writing_offer_name)
    await query.answer()

@router.message(Form.writing_offer_name)
async def write_offer_name(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return

    offer_name = message.text.strip()
    await state.update_data(offer_name=offer_name)

    msg = await message.answer("–í–≤–µ–¥–∏—Ç–µ –¢–ó –¥–ª—è –ª–µ–Ω–¥–∏–Ω–≥–∞:", reply_markup=cancel_kb)
    last_messages[message.from_user.id] = [msg.message_id]
    await state.set_state(Form.writing_specification)

ready_kb = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ")],
        [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
    ],
    resize_keyboard=True,
    one_time_keyboard=False
)

@router.message(F.text == "üñºÔ∏è –£–Ω–∏–∫–∞–ª–∏–∑–∞—Ç–æ—Ä")
async def images_unicalization_initiation(message: Message, state: FSMContext):
    if not is_user_allowed(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.")
        return
    m1 = await message.answer("–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è —É–Ω–∏–∫–∞–ª–∏–∑–∞—Ü–∏–∏ (–æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ)")
    m2 = await message.answer("‚ùå –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –Ω–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏", reply_markup=cancel_kb)
    last_messages[message.from_user.id] = [m1.message_id, m2.message_id]
    await state.set_state(Form.images_unicalization)

@router.message(Form.images_unicalization)
async def receive_image(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return

    if message.photo or (message.document and message.document.mime_type.startswith('image/')):
        file_id = (
            message.photo[-1].file_id if message.photo
            else message.document.file_id
        )
        await state.update_data(unicalization_file_id=file_id)
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–ø–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, 5):", reply_markup=cancel_kb)
        await state.set_state(Form.unicalization_copies)
    else:
        await message.answer("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (—Ñ–æ—Ç–æ –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç).", reply_markup=cancel_kb)

@router.message(Form.unicalization_copies)
async def receive_copy_count(message: Message, state: FSMContext, bot: Bot):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return

    if not message.text.isdigit() or int(message.text) <= 0:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∫–æ–ø–∏–π.", reply_markup=cancel_kb)
        return

    count = int(message.text)
    if count > 40:
        await message.answer("‚ö†Ô∏è –ù–µ–ª—å–∑—è —Å–æ–∑–¥–∞—Ç—å –±–æ–ª–µ–µ 40 –∫–æ–ø–∏–π –∑–∞ —Ä–∞–∑. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 40.", reply_markup=cancel_kb)
        return

    data = await state.get_data()
    unicalization_file_id = data.get("unicalization_file_id")

    await message.answer("üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...", reply_markup=cancel_kb)
    try:
        images_zip = await process_image(bot, unicalization_file_id, message.chat.id, count)
        await bot.send_document(message.chat.id, document=images_zip)
        await message.answer(f"‚úÖ –£–Ω–∏–∫–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {count} –∫–æ–ø–∏–π.", reply_markup=menu_kb_user)
    except Exception as e:
        bugsnag.notify(e)
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.")

    await state.clear()

def generate_random_filename(length=12, ext='jpg'):
    random_str = ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    return f"{random_str}.{ext}"

async def process_image(bot: Bot, file_id: str, user_id: int, copies: int) -> BufferedInputFile:
    file = await bot.get_file(file_id)
    file_content = await bot.download_file(file.file_path)
    file_name = file.file_path.split('/')[-1]
    name_parts = file_name.rsplit('.', 1)
    ext = name_parts[1] if len(name_parts) > 1 else 'jpg'

    zip_buffer = BytesIO()
    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
        for i in range(copies):
            unique_file_name = generate_random_filename(ext=ext)

            img_processed, img_format = modify_image(BytesIO(file_content.getvalue()))
            output = BytesIO()
            save_params = {}

            if img_format.upper() in ('JPEG', 'JPG'):
                save_params['quality'] = random.randint(92, 98)
                save_params['optimize'] = True
            elif img_format.upper() == 'PNG':
                save_params['optimize'] = True
                save_params['compress_level'] = random.randint(6, 9)
            elif img_format.upper() == 'WEBP':
                save_params['quality'] = random.randint(92, 98)
                save_params['method'] = 6
            elif img_format.upper() == 'TIFF':
                save_params['compression'] = 'tiff_lzw'

            if img_format.upper() == 'JPEG' and hasattr(img_processed, '_exif'):
                img_processed.save(output, format=img_format, exif=img_processed._exif, **save_params)
            elif img_format.upper() == 'PNG' and hasattr(img_processed, '_png_info'):
                img_processed.save(output, format=img_format, pnginfo=img_processed._png_info, **save_params)
            else:
                img_processed.save(output, format=img_format, **save_params)

            output.seek(0)
            zip_file.writestr(unique_file_name, output.read())

    zip_buffer.seek(0)
    zip_filename = f"images_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
    return BufferedInputFile(zip_buffer.read(), filename=zip_filename)

def modify_image(file_content: BytesIO) -> Tuple[Image.Image, str]:
    """Apply random filter and change metadata"""
    file_content.seek(0)
    img = Image.open(file_content)
    img_format = img.format or "JPEG"
    
    # Make a copy of the image to ensure it's writable
    img = img.copy()

    if img.mode == 'P':
        img = img.convert('RGBA' if 'transparency' in img.info else 'RGB')

    # Apply a subtle random transformation
    filter_type = random.choice(['brightness', 'contrast', 'color', 'sharpness', 'blur', 'noise', 'rotate'])

    if filter_type == 'brightness':
        img = ImageEnhance.Brightness(img).enhance(random.uniform(0.99, 1.01))
    elif filter_type == 'contrast':
        img = ImageEnhance.Contrast(img).enhance(random.uniform(0.99, 1.01))
    elif filter_type == 'color' and img.mode in ('RGB', 'RGBA'):
        img = ImageEnhance.Color(img).enhance(random.uniform(0.99, 1.01))
    elif filter_type == 'sharpness':
        img = ImageEnhance.Sharpness(img).enhance(random.uniform(0.99, 1.01))
    elif filter_type == 'blur':
        img = img.filter(ImageFilter.GaussianBlur(radius=0.1))
    elif filter_type == 'noise' and img.mode in ('RGB', 'RGBA'):
        for _ in range(3):
            x, y = random.randint(0, img.width - 1), random.randint(0, img.height - 1)
            px = list(img.getpixel((x, y)))
            for i in range(min(3, len(px))):
                px[i] = max(0, min(255, px[i] + random.randint(-1, 1)))
            img.putpixel((x, y), tuple(px))
    elif filter_type == 'rotate':
        img = img.rotate(random.uniform(-0.1, 0.1), resample=Image.BICUBIC, expand=False)

    # Minor pixel edit
    if img.mode in ('RGB', 'RGBA'):
        x, y = random.randint(0, img.width - 1), random.randint(0, img.height - 1)
        px = list(img.getpixel((x, y)))
        i = random.randint(0, min(3, len(px)) - 1)
        px[i] = max(0, min(255, px[i] + random.choice([-1, 1])))
        img.putpixel((x, y), tuple(px))

    unique_id = uuid.uuid4().hex
    current_time = datetime.now().strftime("%Y:%m:%d %H:%M:%S")

    # === Prepare metadata based on format ===
    if img_format.upper() in ('JPEG', 'JPG'):
        exif_dict = {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}
        exif_dict["0th"][piexif.ImageIFD.Make] = f"Camera{random.randint(1,9999)}".encode()
        exif_dict["0th"][piexif.ImageIFD.Model] = f"Model{random.randint(1,9999)}".encode()
        exif_dict["0th"][piexif.ImageIFD.Software] = f"Software{random.randint(1,9999)}".encode()
        exif_dict["0th"][piexif.ImageIFD.Artist] = f"Artist{random.randint(1,999)}".encode()
        exif_dict["0th"][piexif.ImageIFD.Copyright] = f"Copyright{random.randint(1,999)}".encode()
        exif_dict["0th"][piexif.ImageIFD.ImageDescription] = f"Image{random.randint(1,9999)}".encode()
        exif_dict["Exif"][piexif.ExifIFD.DateTimeOriginal] = current_time.encode()
        exif_dict["Exif"][piexif.ExifIFD.DateTimeDigitized] = current_time.encode()
        exif_dict["Exif"][piexif.ExifIFD.ExifVersion] = b"0230"
        exif_dict["Exif"][piexif.ExifIFD.LensMake] = f"Lens{random.randint(1,999)}".encode()
        exif_dict["Exif"][piexif.ExifIFD.LensModel] = f"LensModel{random.randint(1,999)}".encode()
        exif_dict["Exif"][piexif.ExifIFD.UserComment] = f"UniqueID:{unique_id}".encode()

        lat = abs(random.uniform(-90, 90))
        lon = abs(random.uniform(-180, 180))
        lat_ref = 'N' if lat >= 0 else 'S'
        lon_ref = 'E' if lon >= 0 else 'W'

        def to_deg_tuple(val):
            deg = int(val)
            min_ = int((val - deg) * 60)
            sec = int((((val - deg) * 60) - min_) * 60)
            return ((deg, 1), (min_, 1), (sec, 1))

        exif_dict["GPS"][piexif.GPSIFD.GPSLatitudeRef] = lat_ref.encode()
        exif_dict["GPS"][piexif.GPSIFD.GPSLatitude] = to_deg_tuple(lat)
        exif_dict["GPS"][piexif.GPSIFD.GPSLongitudeRef] = lon_ref.encode()
        exif_dict["GPS"][piexif.GPSIFD.GPSLongitude] = to_deg_tuple(lon)
        exif_dict["GPS"][piexif.GPSIFD.GPSDateStamp] = datetime.now().strftime("%Y:%m:%d").encode()

        # Apply EXIF data directly during the return instead of reopening the image
        exif_bytes = piexif.dump(exif_dict)
        img._exif = exif_bytes  # Store the EXIF data to be used during save()
        
    elif img_format.upper() == 'PNG':
        # Create PNG metadata to be used during save()
        metadata = PngInfo()
        metadata.add_text("Software", f"Editor{random.randint(1, 9999)}")
        metadata.add_text("Creation Time", current_time)
        metadata.add_text("UniqueID", unique_id)
        metadata.add_text("Description", f"Image {random.randint(1000, 9999)}")
        metadata.add_text("Author", f"Author{random.randint(1, 999)}")
        metadata.add_text("Copyright", f"Copyright{random.randint(1, 999)}")
        metadata.add_text("Comment", f"Processed on {current_time}")
        metadata.add_text("Disclaimer", f"Generated image {random.randint(1, 9999)}")
        metadata.add_text("Source", f"Source{random.randint(1, 999)}")
        metadata.add_text("Title", f"Title{random.randint(1, 999)}")
        img._png_info = metadata  # Store PNG info to be used during save()

    # No need to save and reopen the image here - we'll return the processed image
    # and its format, and let the caller save it with the appropriate parameters
    return img, img_format

@router.message(Form.writing_specification)
async def write_specification(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return

    if message.text == "‚úÖ –ì–æ—Ç–æ–≤–æ":
        data = await state.get_data()
        landing_category = data.get("landing_category")

        if landing_category == "create":
            msg = await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ canvas –∏–∑ Chat GPT:", reply_markup=cancel_kb)
            last_messages[message.from_user.id] = [msg.message_id]
            await state.set_state(Form.entering_canvas_link)
        else:
            msg = await message.answer("–ó–∞–≥—Ä—É–∑–∏—Ç–µ ZIP –∞—Ä—Ö–∏–≤—ã —Å —Ñ–∞–π–ª–∞–º–∏ –ª–µ–Ω–¥–∏–Ω–≥–∞ (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ).\n–ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–∂–º–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ':", reply_markup=ready_kb)
            last_messages[message.from_user.id] = [msg.message_id]
            await state.set_state(Form.uploading_multiple_zip_files)
        return

    data = await state.get_data()
    spec_text = data.get("specification", "")
    spec_image_ids = data.get("spec_image_ids", [])
    spec_doc_ids = data.get("spec_doc_ids", [])

    if message.text:
        spec_text += ("\n" if spec_text else "") + message.text.strip()

    if message.photo:
        largest_photo = message.photo[-1]
        spec_image_ids.append(largest_photo.file_id)

    elif message.document:
        spec_doc_ids.append(message.document.file_id)

    await state.update_data(
        specification=spec_text,
        spec_image_ids=spec_image_ids,
        spec_doc_ids=spec_doc_ids
    )

    await message.answer(
        "‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ. –ú–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ç–µ–∫—Å—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.\n–ö–æ–≥–¥–∞ –≤—Å—ë –≥–æ—Ç–æ–≤–æ ‚Äî –Ω–∞–∂–º–∏—Ç–µ *–ì–æ—Ç–æ–≤–æ*",
        reply_markup=ready_kb,
        parse_mode="Markdown"
    )

VALID_LINK_REGEX = re.compile(r"^https:\/\/chatgpt\.com\/canvas\/shared\/[a-zA-Z0-9]+$")

@router.message(Form.entering_canvas_link)
async def enter_canvas_link(message: Message, state: FSMContext):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–º–µ–Ω–∞ –ª–∏ —ç—Ç–æ
    if message.text and message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return
        
   # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–µ–∫—Å—Ç —è–≤–ª—è–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Å—Å—ã–ª–∫–æ–π
    if not message.text or not VALID_LINK_REGEX.match(message.text.strip()):
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –≤–∏–¥–∞:\nhttps://chatgpt.com/canvas/shared/...")
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É
    await state.update_data(canvas_link=message.text.strip())

    msg = await message.answer(
        "–ó–∞–≥—Ä—É–∑–∏—Ç–µ ZIP –∞—Ä—Ö–∏–≤—ã —Å –∫–∞—Ä—Ç–∏–Ω–∫–∞–º–∏ (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ).\n–ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –Ω–∞–∂–º–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ':",
        reply_markup=ready_kb
    )
    last_messages[message.from_user.id] = [msg.message_id]
    await state.set_state(Form.uploading_multiple_zip_files)

@router.message(Form.uploading_multiple_zip_files)
async def upload_multiple_zip_files(message: Message, state: FSMContext):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–º–µ–Ω–∞ –ª–∏ —ç—Ç–æ
    if message.text and message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return
        
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≥–æ—Ç–æ–≤–æ –ª–∏
    if message.text and message.text == "‚úÖ –ì–æ—Ç–æ–≤–æ":
        data = await state.get_data()
        zip_files = data.get("zip_files", [])

        if not zip_files:
            await message.answer("‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω ZIP –∞—Ä—Ö–∏–≤ –ø–µ—Ä–µ–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ–º.")
            return

        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏
        await finalize_landing_request(message, state)
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –¥–æ–∫—É–º–µ–Ω—Ç
    if not message.document:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ ZIP –∞—Ä—Ö–∏–≤ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ' –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ zip —Ñ–∞–π–ª
    if message.document.mime_type != "application/zip":
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ ZIP –∞—Ä—Ö–∏–≤ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ' –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.")
        return

    # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –∫ —Å–ø–∏—Å–∫—É
    data = await state.get_data()
    zip_files = data.get("zip_files", [])
    zip_files.append(message.document.file_id)
    await state.update_data(zip_files=zip_files)

    await message.answer(f"‚úÖ –ê—Ä—Ö–∏–≤ –¥–æ–±–∞–≤–ª–µ–Ω ({len(zip_files)} –∑–∞–≥—Ä—É–∂–µ–Ω–æ). –ú–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë –∏–ª–∏ –Ω–∞–∂–∞—Ç—å '–ì–æ—Ç–æ–≤–æ'.")

async def finalize_landing_request(message: Message, state: FSMContext):
    data = await state.get_data()
    user_id = message.from_user.id
    username = message.from_user.username or "–Ω–µ—Ç username"
    offer_name = data.get("offer_name")
    landing_category = data.get("landing_category")
    category = "–°–æ–∑–¥–∞—Ç—å –ª–µ–Ω–¥–∏–Ω–≥" if landing_category == "create" else "–ü–æ—á–∏–Ω–∏—Ç—å –ª–µ–Ω–¥–∏–Ω–≥" if landing_category == "repair" else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    specification = data.get("specification")
    spec_images = data.get("spec_image_ids", [])
    spec_docs = data.get("spec_doc_ids", [])
    order_id = shortuuid.uuid()
    canvas_link = data.get("canvas_link") if landing_category == "create" else None
    zip_files = data.get("zip_files", [])

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –í–∑—è—Ç—å –≤ —Ä–∞–±–æ—Ç—É", callback_data=f"processing:{user_id}")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ", callback_data=f"decline:{user_id}")]
    ])
        
    caption_text = "üñºÔ∏è –ö–∞—Ä—Ç–∏–Ω–∫–∏" if landing_category == "create" else "üìÑ –õ–µ–Ω–¥–∏–Ω–≥"

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ ZIP —Ñ–∞–π–ª—ã
    for i, zip_file_id in enumerate(zip_files, 1):
        caption = f"{caption_text} ({i}/{len(zip_files)})" if len(zip_files) > 1 else caption_text
        await bot.send_document(ADMIN_ID, document=zip_file_id, caption=caption)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏–∑ –¢–ó
    for file_id in spec_images:
        await bot.send_photo(ADMIN_ID, file_id)
    for file_id in spec_docs:
        await bot.send_document(ADMIN_ID, file_id)
        
    message_text = (
        f"üÜî –ó–∞—è–≤–∫–∞: {order_id}\n"
        f"üë§ –û—Ç: @{username} (ID: {user_id})\n"
        f"üìù –û—Ñ—Ñ–µ—Ä: {offer_name}\n"
        f"üîß –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}\n"
        f"üì¶ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä—Ö–∏–≤–æ–≤: {len(zip_files)}\n"
        f"üìù –¢–ó: {specification}\n"
        f"{f'üîó –°—Å—ã–ª–∫–∞ –Ω–∞ Canvas: {canvas_link}\n' if canvas_link else ''}"
    )

    await bot.send_message(
        ADMIN_ID,
        message_text,
        reply_markup=kb
    )
    
    gc = gspread.service_account(filename='credentials.json')
    table = gc.open_by_key(GOOGLE_SHEET_ID)
    worksheet = table.get_worksheet(0)
    worksheet.append_row([order_id, username, user_id, offer_name, category, specification, canvas_link])
    
    await message.answer(f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ {order_id} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", reply_markup=menu_kb_user)
    await state.clear()

@router.message(F.text == "üí∞ –ó–∞–∫–∞–∑–∞—Ç—å –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ")
async def order_topup(message: Message, state: FSMContext):
    if not is_user_allowed(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.")
        return
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üè¶ AdsCard", callback_data="bank:adscard"),
         InlineKeyboardButton(text="üí≥ Traffic.cards", callback_data="bank:trafficcards")]
    ])
    m1 = await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –±–∞–Ω–∫:", reply_markup=kb)
    m2 = await message.answer("‚ùå –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –Ω–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏", reply_markup=cancel_kb)
    last_messages[message.from_user.id] = [m1.message_id, m2.message_id]
    await state.set_state(Form.waiting_for_bank)

@router.callback_query(F.data.startswith("bank:"), Form.waiting_for_bank)
async def bank_selected(query: CallbackQuery, state: FSMContext):
    await delete_last_messages(query.from_user.id, query.message)
    _, bank = query.data.split(":")
    await state.update_data(bank=bank)
    msg = await query.message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:", reply_markup=cancel_kb)
    last_messages[query.from_user.id] = [msg.message_id]
    await state.set_state(Form.waiting_for_amount)
    await query.answer()

@router.message(Form.waiting_for_amount)
async def get_amount(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return
    amount = message.text.strip()
    if not amount.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É.")
        return
    await delete_last_messages(message.from_user.id, message)
    await state.update_data(amount=amount)

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ö° –°—Ä–æ—á–Ω–æ–µ", callback_data="type:urgent"),
         InlineKeyboardButton(text="üïò –ù–µ —Å—Ä–æ—á–Ω–æ–µ (–¥–æ 21:00)", callback_data="type:normal")]
    ])
    m1 = await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:", reply_markup=kb)
    m2 = await message.answer("‚ùå –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –Ω–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏", reply_markup=cancel_kb)
    last_messages[message.from_user.id] = [m1.message_id, m2.message_id]
    await state.set_state(Form.waiting_for_type)

@router.callback_query(F.data.startswith("type:"), Form.waiting_for_type)
async def type_selected(query: CallbackQuery, state: FSMContext):
    await delete_last_messages(query.from_user.id, query.message)
    _, topup_type = query.data.split(":")
    await state.update_data(topup_type=topup_type)

    user_id = query.from_user.id
    username = query.from_user.username or "–Ω–µ—Ç username"
    data = await state.get_data()

    bank = data.get("bank", "–Ω–µ —É–∫–∞–∑–∞–Ω")
    amount = data.get("amount", "–Ω–µ —É–∫–∞–∑–∞–Ω–æ")
    topup_type_text = "‚ö° –°—Ä–æ—á–Ω–æ–µ" if topup_type == "urgent" else "üïò –ù–µ —Å—Ä–æ—á–Ω–æ–µ (–¥–æ 21:00)"

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"approve:{user_id}"),
         InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ", callback_data=f"decline:{user_id}")]
    ])

    await bot.send_message(
        ADMIN_ID,
        f"üîî –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –æ—Ç @{username} (ID: {user_id})\n"
        f"üè¶ –ë–∞–Ω–∫: {bank}\n"
        f"üí≥ –°—É–º–º–∞: {amount}\n"
        f"üìå –¢–∏–ø: {topup_type_text}",
        reply_markup=kb
    )
    await query.message.answer("–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", reply_markup=menu_kb_user)
    await state.clear()
    await query.answer()

@router.message(F.text == "üìÇ –ó–∞–ø—Ä–æ—Å–∏—Ç—å —Ä–∞—Å—Ö–æ–¥–Ω–∏–∫–∏")
async def request_supplies(message: Message, state: FSMContext):
    if not is_user_allowed(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.")
        return
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üë§ –ê–∫–∫–∞—É–Ω—Ç—ã", callback_data="supply:accounts")],
        [InlineKeyboardButton(text="üåê –î–æ–º–µ–Ω—ã", callback_data="supply:domains")]
    ])
    m1 = await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ä–∞—Å—Ö–æ–¥–Ω–∏–∫–æ–≤:", reply_markup=kb)
    m2 = await message.answer("‚ùå –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –Ω–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏", reply_markup=cancel_kb)
    last_messages[message.from_user.id] = [m1.message_id, m2.message_id]
    await state.set_state(Form.choosing_supply_category)

@router.callback_query(F.data.startswith("supply:"), Form.choosing_supply_category)
async def supply_category_selected(query: CallbackQuery, state: FSMContext):
    await delete_last_messages(query.from_user.id, query.message)
    _, category = query.data.split(":")
    await state.update_data(category=category)
    
    if category == "accounts":
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üë§ –°–µ—Ç–∞–ø –ö–ò–ù–ì+\n10 –∞–≤—Ç–æ—Ä–µ–≥–æ–≤", callback_data="acc:set1")],
            [InlineKeyboardButton(text="üë§ –ö–ò–ù–ì + 1-3 –ë–ú", callback_data="acc:set2")],
            [InlineKeyboardButton(text="üë§ –ê–≤—Ç–æ—Ä–µ–≥–∏", callback_data="acc:set3")]
        ])
        m1 = await query.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é (–µ—Å–ª–∏ –Ω–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏, —Ç–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–æ —Ç–æ, —á—Ç–æ –µ—Å—Ç—å):", reply_markup=kb)
        m2 = await query.message.answer("‚ùå –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –Ω–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏", reply_markup=cancel_kb)
        last_messages[query.from_user.id] = [m1.message_id, m2.message_id]
        await state.set_state(Form.choosing_account_type)
    elif category == "domains":
        msg = await query.message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–º–µ–Ω–æ–≤:", reply_markup=cancel_kb)
        last_messages[query.from_user.id] = [msg.message_id]
        await state.set_state(Form.entering_domain_quantity)
    
    await query.answer()

@router.callback_query(F.data.startswith("acc:"), Form.choosing_account_type)
async def account_type_chosen(query: CallbackQuery, state: FSMContext):
    await delete_last_messages(query.from_user.id, query.message)
    _, acc_type = query.data.split(":")
    await state.update_data(account_type=acc_type)
    
    msg = await query.message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤:", reply_markup=cancel_kb)
    last_messages[query.from_user.id] = [msg.message_id]
    await state.set_state(Form.entering_account_quantity)
    await query.answer()

@router.message(Form.entering_account_quantity)
async def get_account_quantity(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return
    
    quantity = message.text.strip()
    if not quantity.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.")
        return
    
    await delete_last_messages(message.from_user.id, message)
    await state.update_data(quantity=quantity)
    
    user_id = message.from_user.id
    username = message.from_user.username or "–Ω–µ—Ç username"
    data = await state.get_data()
    
    account_type_text = {
        "set1": "üë§ –°–µ—Ç–∞–ø –ö–ò–ù–ì+10 –∞–≤—Ç–æ—Ä–µ–≥–æ–≤",
        "set2": "üë§ –ö–ò–ù–ì + 1-3 –ë–ú",
        "set3": "üë§ –ê–≤—Ç–æ—Ä–µ–≥–∏"
    }.get(data.get("account_type"), "üë§ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"approve:{user_id}"),
         InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ", callback_data=f"decline:{user_id}")]
    ])
    
    await bot.send_message(
        ADMIN_ID,
        f"üîî –ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–∞—Å—Ö–æ–¥–Ω–∏–∫–∏ –æ—Ç @{username} (ID: {user_id})\n"
        f"üìÅ –¢–∏–ø: –ê–∫–∫–∞—É–Ω—Ç—ã\n"
        f"üîë –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: {account_type_text}\n"
        f"üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity}",
        reply_markup=kb
    )
    
    await message.answer("–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", reply_markup=menu_kb_user)
    await state.clear()

@router.message(Form.entering_domain_quantity)
async def get_domain_quantity(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await cancel_handler(message, state)
        return
    
    quantity = message.text.strip()
    if not quantity.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ.")
        return
    
    await delete_last_messages(message.from_user.id, message)
    await state.update_data(quantity=quantity)
    
    user_id = message.from_user.id
    username = message.from_user.username or "–Ω–µ—Ç username"
    
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"approve:{user_id}"),
         InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ", callback_data=f"decline:{user_id}")]
    ])
    
    await bot.send_message(
        ADMIN_ID,
        f"üîî –ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–∞—Å—Ö–æ–¥–Ω–∏–∫–∏ –æ—Ç @{username} (ID: {user_id})\n"
        f"üìÅ –¢–∏–ø: –î–æ–º–µ–Ω—ã\n"
        f"üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity}",
        reply_markup=kb
    )
    
    await message.answer("–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", reply_markup=menu_kb_user)
    await state.clear()

@router.callback_query(F.data.startswith("approve:"))
async def approve_request(query: CallbackQuery):
    _, user_id = query.data.split(":")
    user_id = int(user_id)
    
    await bot.send_message(
        user_id,
        "‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞ –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
    )
    
    await query.message.edit_text(
        f"{query.message.text}\n\n‚úÖ –í–´–ü–û–õ–ù–ï–ù–û"
    )
    await query.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–≤–µ–¥–æ–º–ª–µ–Ω –æ–± –æ–¥–æ–±—Ä–µ–Ω–∏–∏")
    
@router.callback_query(F.data.startswith("processing:"))
async def processing_request(query: CallbackQuery):
    _, user_id = query.data.split(":")
    user_id = int(user_id)
    
    await bot.send_message(
        user_id,
        "‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∞ –∏ –≤–∑—è—Ç–∞ –≤ —Ä–∞–±–æ—Ç—É."
    )
    
    await query.message.edit_text(
        f"{query.message.text}\n\n‚úÖ –í –†–ê–ë–û–¢–ï"
    )
    await query.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–≤–µ–¥–æ–º–ª–µ–Ω –æ –≤–∑—è—Ç–∏–∏ –≤ —Ä–∞–±–æ—Ç—É")

@router.callback_query(F.data.startswith("decline:"))
async def decline_request(query: CallbackQuery):
    _, user_id = query.data.split(":")
    user_id = int(user_id)
    
    await bot.send_message(
        user_id,
        "‚ùå –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
    )
    
    await query.message.edit_text(
        f"{query.message.text}\n\n‚ùå –û–¢–ö–õ–û–ù–ï–ù–û"
    )
    await query.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–≤–µ–¥–æ–º–ª–µ–Ω –æ–± –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏")

@router.message(F.text == "‚ùå –û—Ç–º–µ–Ω–∞")
async def cancel_handler(message: Message, state: FSMContext):
    await delete_last_messages(message.from_user.id, message)
    await state.clear()
    await message.answer("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ. –í–æ–∑–≤—Ä–∞—â–∞—é –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ‚¨ÖÔ∏è", reply_markup=menu_kb_user)

async def delete_last_messages(user_id, current_message):
    ids = last_messages.get(user_id, [])
    for msg_id in ids:
        try:
            await current_message.bot.delete_message(chat_id=user_id, message_id=msg_id)
        except Exception:
            pass
    last_messages[user_id] = []

def is_user_allowed(user_id: int) -> bool:
    user_ids = get_user_ids_from_sheet()
    if not user_ids:
        return False  # –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç, –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω

    return user_id in user_ids

def get_user_ids_from_sheet() -> list[int]:
    gc = gspread.service_account(filename='credentials.json')
    table = gc.open_by_key(GOOGLE_SHEET_ID)
    worksheet = table.get_worksheet(1)
    user_ids = worksheet.col_values(1)

    return [int(user_id) for user_id in user_ids if user_id.isdigit()]

async def main():
    await bot.delete_webhook(drop_pending_updates=True)  # –µ—Å–ª–∏ –∑–∞–ø—É—Å–∫–∞–µ—à—å polling
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
